{"version":3,"sources":["overflowManager.js"],"sourcesContent":["import { DATA_OVERFLOWING, DATA_OVERFLOW_GROUP } from './consts';\nimport { observeResize } from './createResizeObserver';\nimport { debounce } from './debounce';\nimport { createPriorityQueue } from './priorityQueue';\n/**\n * @internal\n * @returns overflow manager instance\n */ export function createOverflowManager() {\n    // calls to `offsetWidth or offsetHeight` can happen multiple times in an update\n    // Use a cache to avoid causing too many recalcs and avoid scripting time to meausure sizes\n    const sizeCache = new Map();\n    let container;\n    let overflowMenu;\n    // Set as true when resize observer is observing\n    let observing = false;\n    // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change\n    // Initially true to force dispatch on first mount\n    let forceDispatch = true;\n    const options = {\n        padding: 10,\n        overflowAxis: 'horizontal',\n        overflowDirection: 'end',\n        minimumVisible: 0,\n        onUpdateItemVisibility: ()=>undefined,\n        onUpdateOverflow: ()=>undefined\n    };\n    const overflowItems = {};\n    const overflowDividers = {};\n    let disposeResizeObserver = ()=>null;\n    const getNextItem = (queueToDequeue, queueToEnqueue)=>{\n        const nextItem = queueToDequeue.dequeue();\n        queueToEnqueue.enqueue(nextItem);\n        return overflowItems[nextItem];\n    };\n    const createGroupManager = ()=>{\n        const groupVisibility = {};\n        const groups = {};\n        function updateGroupVisibility(groupId) {\n            const group = groups[groupId];\n            if (group.invisibleItemIds.size && group.visibleItemIds.size) {\n                groupVisibility[groupId] = 'overflow';\n            } else if (group.visibleItemIds.size === 0) {\n                groupVisibility[groupId] = 'hidden';\n            } else {\n                groupVisibility[groupId] = 'visible';\n            }\n        }\n        function isGroupVisible(groupId) {\n            return groupVisibility[groupId] === 'visible' || groupVisibility[groupId] === 'overflow';\n        }\n        return {\n            groupVisibility: ()=>groupVisibility,\n            isSingleItemVisible (itemId, groupId) {\n                return isGroupVisible(groupId) && groups[groupId].visibleItemIds.has(itemId) && groups[groupId].visibleItemIds.size === 1;\n            },\n            addItem (itemId, groupId) {\n                var _groups, _groupId;\n                var _;\n                (_ = (_groups = groups)[_groupId = groupId]) !== null && _ !== void 0 ? _ : _groups[_groupId] = {\n                    visibleItemIds: new Set(),\n                    invisibleItemIds: new Set()\n                };\n                groups[groupId].visibleItemIds.add(itemId);\n                updateGroupVisibility(groupId);\n            },\n            removeItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.delete(itemId);\n                groups[groupId].visibleItemIds.delete(itemId);\n                updateGroupVisibility(groupId);\n            },\n            showItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.delete(itemId);\n                groups[groupId].visibleItemIds.add(itemId);\n                updateGroupVisibility(groupId);\n            },\n            hideItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.add(itemId);\n                groups[groupId].visibleItemIds.delete(itemId);\n                updateGroupVisibility(groupId);\n            }\n        };\n    };\n    const groupManager = createGroupManager();\n    function compareItems(lt, rt) {\n        if (!lt || !rt) {\n            return 0;\n        }\n        const lte = overflowItems[lt];\n        const rte = overflowItems[rt];\n        if (lte.priority !== rte.priority) {\n            return lte.priority > rte.priority ? 1 : -1;\n        }\n        const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;\n        // eslint-disable-next-line no-bitwise\n        return lte.element.compareDocumentPosition(rte.element) & positionStatusBit ? 1 : -1;\n    }\n    function getElementAxisSize(horizontal, vertical, el) {\n        if (!sizeCache.has(el)) {\n            sizeCache.set(el, options.overflowAxis === 'horizontal' ? el[horizontal] : el[vertical]);\n        }\n        return sizeCache.get(el);\n    }\n    const getOffsetSize = getElementAxisSize.bind(null, 'offsetWidth', 'offsetHeight');\n    const getClientSize = getElementAxisSize.bind(null, 'clientWidth', 'clientHeight');\n    const invisibleItemQueue = createPriorityQueue((a, b)=>-1 * compareItems(a, b));\n    const visibleItemQueue = createPriorityQueue(compareItems);\n    function occupiedSize() {\n        const totalItemSize = visibleItemQueue.all().map((id)=>overflowItems[id].element).map(getOffsetSize).reduce((prev, current)=>prev + current, 0);\n        const totalDividerSize = Object.entries(groupManager.groupVisibility()).reduce((acc, [id, state])=>acc + (state !== 'hidden' && overflowDividers[id] ? getOffsetSize(overflowDividers[id].element) : 0), 0);\n        const overflowMenuSize = invisibleItemQueue.size() > 0 && overflowMenu ? getOffsetSize(overflowMenu) : 0;\n        return totalItemSize + totalDividerSize + overflowMenuSize;\n    }\n    const showItem = ()=>{\n        const item = getNextItem(invisibleItemQueue, visibleItemQueue);\n        options.onUpdateItemVisibility({\n            item,\n            visible: true\n        });\n        if (item.groupId) {\n            groupManager.showItem(item.id, item.groupId);\n            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n                var _overflowDividers_item_groupId;\n                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.removeAttribute(DATA_OVERFLOWING);\n            }\n        }\n    };\n    const hideItem = ()=>{\n        const item = getNextItem(visibleItemQueue, invisibleItemQueue);\n        options.onUpdateItemVisibility({\n            item,\n            visible: false\n        });\n        if (item.groupId) {\n            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n                var _overflowDividers_item_groupId;\n                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.setAttribute(DATA_OVERFLOWING, '');\n            }\n            groupManager.hideItem(item.id, item.groupId);\n        }\n    };\n    const dispatchOverflowUpdate = ()=>{\n        const visibleItemIds = visibleItemQueue.all();\n        const invisibleItemIds = invisibleItemQueue.all();\n        const visibleItems = visibleItemIds.map((itemId)=>overflowItems[itemId]);\n        const invisibleItems = invisibleItemIds.map((itemId)=>overflowItems[itemId]);\n        options.onUpdateOverflow({\n            visibleItems,\n            invisibleItems,\n            groupVisibility: groupManager.groupVisibility()\n        });\n    };\n    const processOverflowItems = ()=>{\n        if (!container) {\n            return false;\n        }\n        sizeCache.clear();\n        const availableSize = getClientSize(container) - options.padding;\n        // Snapshot of the visible/invisible state to compare for updates\n        const visibleTop = visibleItemQueue.peek();\n        const invisibleTop = invisibleItemQueue.peek();\n        while(compareItems(invisibleItemQueue.peek(), visibleItemQueue.peek()) > 0){\n            hideItem(); // hide elements whose priority become smaller than the highest priority of the hidden one\n        }\n        // Run the show/hide step twice - the first step might not be correct if\n        // it was triggered by a new item being added - new items are always visible by default.\n        for(let i = 0; i < 2; i++){\n            // Add items until available width is filled - can result in overflow\n            while(occupiedSize() < availableSize && invisibleItemQueue.size() > 0 || invisibleItemQueue.size() === 1 // attempt to show the last invisible item hoping it's size does not exceed overflow menu size\n            ){\n                showItem();\n            }\n            // Remove items until there's no more overflow\n            while(occupiedSize() > availableSize && visibleItemQueue.size() > options.minimumVisible){\n                hideItem();\n            }\n        }\n        // only update when the state of visible/invisible items has changed\n        return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;\n    };\n    const forceUpdate = ()=>{\n        if (processOverflowItems() || forceDispatch) {\n            forceDispatch = false;\n            dispatchOverflowUpdate();\n        }\n    };\n    const update = debounce(forceUpdate);\n    const observe = (observedContainer, userOptions)=>{\n        Object.assign(options, userOptions);\n        observing = true;\n        Object.values(overflowItems).forEach((item)=>visibleItemQueue.enqueue(item.id));\n        container = observedContainer;\n        disposeResizeObserver = observeResize(container, (entries)=>{\n            if (!entries[0] || !container) {\n                return;\n            }\n            update();\n        });\n    };\n    const disconnect = ()=>{\n        observing = false;\n        sizeCache.clear();\n        disposeResizeObserver();\n    };\n    const addItem = (item)=>{\n        if (overflowItems[item.id]) {\n            return;\n        }\n        overflowItems[item.id] = item;\n        // some options can affect priority which are only set on `observe`\n        if (observing) {\n            // Updates to elements might not change the queue tops\n            // i.e. new element is enqueued but the top of the queue stays the same\n            // force a dispatch on the next batched update\n            forceDispatch = true;\n            visibleItemQueue.enqueue(item.id);\n        }\n        if (item.groupId) {\n            groupManager.addItem(item.id, item.groupId);\n            item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);\n        }\n        update();\n    };\n    const addOverflowMenu = (el)=>{\n        overflowMenu = el;\n    };\n    const addDivider = (divider)=>{\n        if (!divider.groupId || overflowDividers[divider.groupId]) {\n            return;\n        }\n        divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);\n        overflowDividers[divider.groupId] = divider;\n    };\n    const removeOverflowMenu = ()=>{\n        overflowMenu = undefined;\n    };\n    const removeDivider = (groupId)=>{\n        if (!overflowDividers[groupId]) {\n            return;\n        }\n        const divider = overflowDividers[groupId];\n        if (divider.groupId) {\n            delete overflowDividers[groupId];\n            divider.element.removeAttribute(DATA_OVERFLOW_GROUP);\n        }\n    };\n    const removeItem = (itemId)=>{\n        if (!overflowItems[itemId]) {\n            return;\n        }\n        const item = overflowItems[itemId];\n        visibleItemQueue.remove(itemId);\n        invisibleItemQueue.remove(itemId);\n        if (item.groupId) {\n            groupManager.removeItem(item.id, item.groupId);\n            item.element.removeAttribute(DATA_OVERFLOW_GROUP);\n        }\n        sizeCache.delete(item.element);\n        delete overflowItems[itemId];\n        update();\n    };\n    return {\n        addItem,\n        disconnect,\n        forceUpdate,\n        observe,\n        removeItem,\n        update,\n        addOverflowMenu,\n        removeOverflowMenu,\n        addDivider,\n        removeDivider\n    };\n}\n"],"names":["createOverflowManager","sizeCache","Map","container","overflowMenu","observing","forceDispatch","options","padding","overflowAxis","overflowDirection","minimumVisible","onUpdateItemVisibility","undefined","onUpdateOverflow","overflowItems","overflowDividers","disposeResizeObserver","getNextItem","queueToDequeue","queueToEnqueue","nextItem","dequeue","enqueue","createGroupManager","groupVisibility","groups","updateGroupVisibility","groupId","group","invisibleItemIds","size","visibleItemIds","isGroupVisible","isSingleItemVisible","itemId","has","addItem","_groups","_groupId","_","Set","add","removeItem","delete","showItem","hideItem","groupManager","compareItems","lt","rt","lte","rte","priority","positionStatusBit","Node","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","element","compareDocumentPosition","getElementAxisSize","horizontal","vertical","el","set","get","getOffsetSize","bind","getClientSize","invisibleItemQueue","createPriorityQueue","a","b","visibleItemQueue","occupiedSize","totalItemSize","all","map","id","reduce","prev","current","totalDividerSize","Object","entries","acc","state","overflowMenuSize","item","visible","_overflowDividers_item_groupId","removeAttribute","DATA_OVERFLOWING","setAttribute","dispatchOverflowUpdate","visibleItems","invisibleItems","processOverflowItems","clear","availableSize","visibleTop","peek","invisibleTop","i","forceUpdate","update","debounce","observe","observedContainer","userOptions","assign","values","forEach","observeResize","disconnect","DATA_OVERFLOW_GROUP","addOverflowMenu","addDivider","divider","removeOverflowMenu","removeDivider","remove"],"mappings":"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"}